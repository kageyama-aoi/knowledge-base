<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>20260130_Pythonテストコード学習プラン</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<p>Pythonテストコード学習プラン</p>
<p>Week 1: ユニットテスト基礎 – テストの重要性と基本概念</p>
<p>テーマ:
ユニットテストとは何か、なぜ必要かを理解します。まずはPythonコードにおけるユニットテストの役割・利点を学び、シンプルなテストを書いてみる導入週です。
• ユニットテストの意義:
ユニットテストはコードにバグがないことを早期に確認し、リファクタリングや将来の変更でも動作を保証するためのものです。例えば、ユニットテストは本番投入前にバグを発見でき、モジュール化されたテスト可能なコードを書く助けにもなります
￼。自動テストにより手動より速く検証でき、テストが動作例のドキュメントにもなるため、開発効率とコード品質向上に欠かせません
￼ ￼。 • Pythonでのテスト方法:
Python標準のテストフレームワークにはunittestがありますが、最近はより柔軟に書けるサードパーティ製のpytestがデファクトスタンダードになりつつあります
￼。本プランではpytestを中心に進めますが、基礎概念はどのフレームワークでも共通です。まずはテストコードの基本構造（入力を用意→関数を実行→結果を期待値と比較）を押さえましょう。
• 学習動画 (導入):
最初にテスト全体像をつかむため、初心者向けの解説動画を視聴しましょう。例：「【Pythonプログラミング入門】テストコードの書き方を解説！(pytest)」(VTuberサプー)
などは日本語で単体テストの意義とpytestの基本を書籍に沿って紹介しており、入門者に最適です。英語でも問題なければ「PyTest
Tutorial for Absolute
Beginners」等の動画シリーズも参考になります。動画でテストの流れをイメージしたら、実際に手を動かす準備をします。
• ハンズオン練習:
ごく簡単な関数を作り、それに対するユニットテストを書いてみます。例えば「整数が偶数か奇数か判定して文字列を返す関数」を実装し、それに対するテスト関数を2つ用意します（偶数入力に対する期待結果、奇数入力に対する期待結果）。以下はその例です
￼：</p>
<p>def kisuu_guusuu_hantei(num: int) -&gt; str: #
numが偶数か奇数かを返す return “偶数” if num % 2 == 0 else “奇数”</p>
<p>def test_2_guusuu(): assert kisuu_guusuu_hantei(2) == “偶数”</p>
<p>def test_3_kisuu(): assert kisuu_guusuu_hantei(3) == “奇数”</p>
<p>上記のようにassert文で関数の戻り値が期待通りかチェックします。
￼まずはこのテストを実行してみて、グリーン（成功）になることを確認しましょう。もしテストをわざと失敗させてみたい場合は、例えば期待値を間違えて書いてエラー時の出力を観察するのも良い経験です。</p>
<pre><code>•   ポイント: テストは「Arrange（準備）- Act（実行）- Assert（検証）」の流れで記述します。上記のコードでも、まず入力値を用意し（Arrange）、関数を呼び出して（Act）、結果が期待通りかassertで検証しています（Assert） ￼。短いコードでもこの構造を意識しましょう。また、テストコードは独立して繰り返し実行できるようにします。他のテストに依存せず、毎回同じ結果が得られるのが理想です ￼。</code></pre>
<p>Week 2: pytest入門 – テストフレームワークの基本と実践</p>
<p>テーマ:
Pythonのテストフレームワークpytestの基本的な使い方を習得します。環境セットアップからシンプルなテストケースの作成・実行方法、pytestを用いたテストコードの書式を学ぶ週です。
• 環境セットアップ: 仮想環境を作成し、pip install
pytestでpytestをインストールします
￼。テストコードはプロジェクト内で新規に.pyファイルを作り、test_で始まる名前を付けて保存しましょう（pytestはファイル名がtest_<em>.pyまたは</em>_test.pyのファイルを自動検出します
￼）。例えばtest_sample.pyという名前でテストを書いてみます。 •
最初のpytestテスト:
1行だけの簡単なテストから始めます。例えば次のような関数とテストを書き、pytestで実行してみましょう
￼。</p>
<h1 id="ファイル-test_sample.py">ファイル: test_sample.py</h1>
<p>def test_addition(): assert 1 + 1 == 2</p>
<p>上記のテストでは「1+1が2となること」をチェックしています。このファイルを保存し、ターミナルでプロジェクト直下からpytestコマンドを実行すると、pytestが自動でこのテスト関数を発見して実行します
￼。緑色の「.」や「PASSED」が表示されればテスト成功です。pytestではunittestのようなクラス定義やself.assert*を使わず、assert文だけで検証できるためボイラープレートが少なく直感的です
￼。また、失敗時にはどの値が違ったか詳しく表示してくれるのでデバッグもしやすくなっています。</p>
<pre><code>•   テスト関数の書き方: 複数のテストケースがある場合、関数を分けて記述します。関数名はtest_...で始め、何をテストするか分かる名前にしましょう（例えばtest_addition_positive_numbersのように） ￼。pytestは各テスト関数を独立して実行するので、一つの関数では基本一つのシナリオを検証します。Week1で作成したkisuu_guusuu_hantei関数のテストも、pytest版では同様にassertを使って書き直してみてください。
•   テストの実行方法: pytestコマンドを叩くとカレントディレクトリ以下の全てのテストが実行されます ￼。特定のテストだけ実行したい場合は、pytest -k &quot;キーワード&quot;で名前にキーワードを含むテストだけをフィルタできます ￼。失敗したテストはFやEとして表示され、どの行で何が予期されたかメッセージが出ます。まずは少数のテストを実行して結果の見方に慣れてください。
•   学習リソース: pytest公式ドキュメントの「Getting Started」や、初心者向け記事「超初心者向け Pythonのテストの書き方（pytest, unittest）」 ￼ ￼も参考になります。pytestの基本機能と使い方を網羅したチュートリアル（例えばReal Pythonの「Effective Python Testing With pytest」 ￼ ￼）も後で役立つのでブックマークしておきましょう。
•   ハンズオン練習: Week1で作成した関数のテストコードを、クラスを使わずpytest流儀で書き直して実行してみます。さらに、別の簡単な関数を作ってテストを書いてみましょう。例として「文字列が回文（前後対称）か判定する関数」を実装し、空文字や”aba”などいくつかの入力に対してTrue/Falseを返すことを確認するテストを作成します（この課題は次週のパラメータ化テストにもつなげます）。テストを書いたら実行し、全て緑になることを確認してください。テスト名やアサートメッセージにも注目し、どのように失敗が報告されるか観察しましょう。</code></pre>
<p>Week 3: pytest応用 – フィクスチャとパラメータ化によるテスト拡充</p>
<p>テーマ:
pytestの便利機能を使って、より効率的で網羅的なテストを書く方法を学びます。具体的には<strong>フィクスチャ（fixture）</strong>による事前準備・後処理、パラメータ化テストによる入力網羅、例外発生のテスト手法などを習得します。
• フィクスチャ（Fixture）の利用:
フィクスチャとはテスト関数の実行前後に必要な準備や片付けを行う仕組みです。例えば毎回使うデータベース接続や一時ディレクトリの作成などをフィクスチャとして定義できます。pytestでは関数に@pytest.fixtureデコレータを付けてフィクスチャを定義し、テスト関数の引数に同名を指定すると自動で適用されます
￼。簡単な例:</p>
<p>import pytest</p>
<p><span class="citation"
data-cites="pytest.fixture">@pytest.fixture</span> def sample_data(): #
テスト前に実行されるセットアップ処理 return {“users”: [“Alice”, “Bob”,
“Charlie”]}</p>
<p>def test_data_length(sample_data): #
sample_dataフィクスチャが引数で利用可能 assert len(sample_data[“users”])
== 3</p>
<p>上記ではsample_dataフィクスチャがテスト実行時に提供され、ユーザ一覧の長さを検証しています。フィクスチャを使うことでセットアップコードの重複を避け、テストコードをシンプルに保てます。なお、unittestで言うところのsetUp()に相当しますが、pytestのフィクスチャは柔軟に使い回しやスコープ設定（関数単位、モジュール単位など）が可能です
￼。</p>
<pre><code>•   パラメータ化テスト: 同じ種類のテストを異なる入力値で繰り返したい場合、@pytest.mark.parametrizeデコレータを使うと便利です。一つのテスト関数でタプルのリストを渡し、複数ケースを一気に検証できます ￼。例えば前週の回文判定関数をテストする場合、以下のように複数の文字列ケースをパラメータ化できます ￼:</code></pre>
<p>import pytest</p>
<p><span class="citation"
data-cites="pytest.mark.parametrize">@pytest.mark.parametrize</span>(“input_str,
expected”, [ (““, True), # 空文字は回文とみなす (”a”, True), #
1文字は回文 (“ab”, False), # 2文字で異なる -&gt; 回文ではない (“aba”,
True), # 回文 (“racecar”, True), # 長い回文 (“hello”, False) #
回文でない例]) def test_is_palindrome(input_str, expected): assert
is_palindrome(input_str) == expected</p>
<p>上記のようにテストケースをリストで列挙するだけで、pytestが各組み合わせを別テストとして実行してくれます
￼
￼。パラメータ化により境界値や異常系も漏れなくテストしやすくなります。例えば偶奇判定関数についても、0や負数を含め複数パターンを一括テストできます
￼。</p>
<pre><code>•   例外のテスト: 想定通り例外が発生することを確認するには、with pytest.raises(ExceptionType)構文を使います。例えば「引数に0を渡したらValueErrorを投げる関数」をテストする場合 ￼:</code></pre>
<p>import pytest</p>
<p>def divide(a, b): if b == 0: raise ValueError(“ゼロで割れません”)
return a / b</p>
<p>def test_divide_by_zero(): with pytest.raises(ValueError) as
exc_info: divide(10, 0) assert “割れません” in str(exc_info.value)</p>
<p>上記ではdivide(10,0)がValueErrorを発生させること、そしてメッセージに特定の文字列が含まれることを検証しています
￼。exc_info.valueで実際の例外オブジェクトにアクセスでき、メッセージ内容のチェックも可能です。例外が発生しないことの確認（つまり正常終了の確認）は通常の関数呼び出し後にassertするだけでOKです。
￼。</p>
<pre><code>•   学習リソース: pytestの公式ドキュメントにはフィクスチャやパラメータ化の詳細な使い方が載っています。また、日本語の解説記事「pytestの基本と使い方 (Qiita)」 ￼ ￼や、Zennの記事「Pytest初級編」などもフィクスチャとパラメータ化を丁寧に説明しています。併せて読むと理解が深まるでしょう。
•   ハンズオン練習:
1.  フィクスチャ: 簡単なフィクスチャを作り、テストで利用してみましょう。例として、一時ディレクトリを作成してパスを返すフィクスチャを作り、その中にファイルを書き込む関数をテストする、などのシナリオを試します。あるいは疑似的に外部リソース（例えばユーザー一覧データ）を用意するフィクスチャを作り、そのデータに対する処理関数をテストするのも良い練習です。フィクスチャを作ったらスコープ（関数ごとか、モジュールごとか）も変えて挙動を確認してみましょう。
2.  パラメータ化: 前述の回文判定関数is_palindromeのテストを実際にパラメータ化して実行します。さらに、Week1で作った偶奇判定関数について、入力を-2, -1, 0, 1, 2と網羅したパラメータ化テストを作成してみてください。すべてのケースが期待通りに通ることを確認しましょう。こうした境界値テストをまとめて書く癖を付けると、テスト漏れを防ぎつつコードの信頼性を高められます ￼。
3.  例外処理: 0除算や入力値バリデーションなど例外を投げる関数を自作し、その例外が正しく発生するテストを書いてみます。例えば上記のdivide関数のように、自作関数に不正な値を与えてpytest.raisesで期待する例外を確認してください。例外メッセージも検証するとより堅いテストになります。
•   ポイント: この週までで、pytestでテストを書く基本スキルはほぼ身に付いているはずです。フィクスチャでセットアップの重複を排除し、パラメータ化でテストケース網羅性を向上させ、例外テストで異常系もしっかり担保することが重要です。実務でも、共通準備が必要な場合はフィクスチャ化し、様々な入力パターンはパラメータ化してテストを書く習慣をつけましょう。</code></pre>
<p>Week 4: モックと依存関係の分離 – 外部依存を切り離したテスト手法</p>
<p>テーマ:
テスト対象のコードが外部の要因に依存している場合に、それを擬似的に置き換える<strong>モック（mock）</strong>の技法を学びます。外部APIやデータベース、ファイルI/O、ユーザ入力などを直接呼び出すコードをテストする際、モックを使って依存性を分離する方法と、pytestにおけるモック活用方法を習得します。
• モックの概要:
モックとは、実際の外部機能の代替となるダミーオブジェクトです。ユニットテストでは、ネットワークやDBアクセスなど本物を呼ぶと遅い・不確定な処理はモックに差し替え、単体のロジックだけを検証できるようにします
￼。例えば天気情報を取得する関数がrequests.getで外部APIを呼んでいる場合、その部分をモックに置き換えてテストすることで、ネットワークに繋がずとも関数のロジック（レスポンスの処理）が確認できます。
• unittest.mockによるモック:
Python標準のunittest.mockライブラリを使うと、関数やオブジェクトを簡単にモック化できます。典型的なパターンはpatchを用いて特定の関数呼び出しをモックに差し替える方法です
￼。以下に、外部APIを呼ぶクラスをモックでテストする例を示します ￼：</p>
<p>import requests from unittest.mock import patch, Mock</p>
<p>class WeatherService: def get_temperature(self, city): response =
requests.get(f”https://api.weather.com/{city}“) return
response.json()[“temp”]</p>
<p>def test_get_temperature(): service = WeatherService() #
requests.getをモックに差し替える with patch(‘requests.get’) as mock_get:
# モックの戻り値となる擬似レスポンスを定義 mock_response = Mock()
mock_response.json.return_value = {“temp”: 72} mock_get.return_value =
mock_response</p>
<pre><code>    temp = service.get_temperature(&quot;Boston&quot;)
    assert temp == 72  # モックの値が返ってくることを確認
    mock_get.assert_called_once_with(&quot;https://api.weather.com/Boston&quot;)  # 呼び出し内容検証</code></pre>
<p>上記では、requests.get関数をモック化し、呼ばれたら温度72を返す擬似レスポンスを用意しています。こうすることで外部APIに実際にはアクセスせず、決め打ちのレスポンスでサービスクラスのロジックをテストできます
￼。最後にassert_called_once_withでモックが期待通りの引数で呼ばれたかもチェックしています。</p>
<pre><code>•   pytestでのモック活用: pytestでも上記のunittest.mockはそのまま使えますが、より簡潔に書ける方法としてmonkeypatchフィクスチャやpytest-mockプラグインがあります。 ￼ ￼例えばpytest-mockを導入すると、テスト関数にmocker引数を取ってmocker.patchを使えます（内部的にはunittest.mockと同じ動作です）。上記と同じテストはpytest-mockでは次のように書けます ￼：</code></pre>
<p>def test_get_temperature(mocker): service = WeatherService()
mock_response = mocker.Mock() mock_response.json.return_value = {“temp”:
72} mocker.patch(‘requests.get’, return_value=mock_response) assert
service.get_temperature(“Boston”) == 72</p>
<p>標準ライブラリだけで十分ですが、pytestを使うならこうしたプラグインも覚えておくと便利です。簡単なケースでは、pytest組み込みの<strong>monkeypatch</strong>フィクスチャが手軽でしょう。以下は組み込みinput()関数をモックして強制的に特定の文字列を返す例です
￼:</p>
<p>def test_input_monkey(monkeypatch):
monkeypatch.setattr(‘builtins.input’, lambda _: “mocked!”) assert
input(“何か入力:”) == “mocked!”</p>
<p>このようにmonkeypatch.setattrで標準関数を一時的に置き換え、テスト後に自動で元に戻すことができます
￼。monkeypatchは単純なモックに有用ですが、多用するならpytest-mock＋mockerの方が後述の呼び出し検証など高機能で扱いやすいでしょう。</p>
<pre><code>•   依存関係の分離: モックを使う他に、設計レベルで依存性を分離しておくことも重要です。例えば関数内で直接requests.getを呼ぶのではなく、その処理を別関数にし、それを引数経由で渡せるようにするとテスト時に差し替えやすくなります（依存性の注入）。ただし設計変更が大きくなる場合は、上記のようにテスト時だけモックで差し替えるほうが実践的です。要は「外部リソースにアクセスするコード」はユニットテスト上はモックやスタブに置き換えて、テスト対象を純粋な計算ロジックに集中させるのがユニットテストの基本方針です ￼。
•   ハンズオン練習:
1.  API呼び出しのモック: 簡単なHTTP APIクライアント関数を作り、それをテストしてみます。例として「fetch_user(user_id)関数が内部でrequests.get(&quot;.../user/{id}&quot;)を呼びJSONをパースしてユーザ名を返す」という想定のコードを書き、テストではrequests.getをモックして任意のJSONを返すようにします。patchを使い、モックが期待通り呼ばれたか（指定URLで一度だけ呼ばれたか）も検証してください ￼。
2.  組み込み関数のモック: datetimeモジュールやtime.sleep、inputなど組み込み/標準ライブラリを使う自作関数をテストする場合も練習しましょう。例えば「現在時刻を取得して特定フォーマットの文字列を返す関数」を作り、datetime.datetime.now()をモック化して常に決まった日時を返すようにしてテストします。これにより時間に依存せず常に同じ結果をテストできます。monkeypatchフィクスチャを使ってdatetime.datetime.nowを差し替える方法を試してみてください。
3.  副作用のある処理のスタブ: 外部システムへの書き込みやファイル削除など、結果は外部状態に現れるだけの関数もテストしづらいものです。こうした副作用関数について、実際には処理を行わずフラグだけ立てるスタブ関数に置き換えて挙動を検証する練習もしてみましょう。例えばメール送信関数send_email(to, msg)をスタブ化して呼ばれたかどうか（呼び出し回数や引数）だけ確認するテストを書いてみます。unittest.mockのMockオブジェクトは呼び出し履歴を持つので、mock_object.calledやassert_called_with(...)で期待通り使われたか検証できます ￼。
•   ポイント: モックの使い過ぎは複雑になりますが、適切に使えば外部要因によらない安定したテストが実現できます。重要なのは「単体テストは外部システムに依存しない純粋なロジック検証」と割り切ることです ￼。ネットワークやDBを実際に呼ぶ必要があるテストはユニットテストではなく統合テストとして分け、ユニットテストではモックで代替するのが一般的です。こうしておけばユニットテストは高速・安定に多数実行でき、失敗した場合も自分のロジックのバグだとすぐ分かります。</code></pre>
<p>Week 5: テストコードのベストプラクティス –
品質と保守性を高める作法</p>
<p>テーマ:
テストコード自体の品質と保守しやすさを向上させるためのベストプラクティスを体系的に学びます。具体的にはテスト命名,
コードカバレッジ, テストの独立性,
テスト対象の選定などについて、記事や書籍の知見を通じて理解します。 •
命名規則と構造:
テストコードの名前付けは明確さが命です。テストファイル名は先述の通りtest_…で始め、テスト関数名も何をどうするテストか分かるように書きます（例:
test_user_creation_with_valid_dataなど） ￼。曖昧な名前（例:
test1()やtest_function()）は避け、テスト内容を端的に表しましょう
￼。また1テスト関数=1動作検証を基本にします。一つのテストでアサートは1～2個程度に留め、長くなりすぎるようならシナリオごとに関数を分けます（※厳密に「1テスト1アサート」にこだわる必要はありませんが、ガイドラインとして覚えておきましょう
￼）。テスト関数内はArrange-Act-Assertの順でコードを段落分けすると読みやすくなります
￼。例えば、最初にテストデータ準備、次に対象関数呼び出し、最後に結果検証、というブロックにコメントを付けて整理する方法があります
￼。 • テストの独立性:
各テストケースは他のテストから独立して実行できなければなりません
￼。テスト間でグローバル変数を共有したり、実行順序に依存するのは避けます。pytestでは基本的にテストの実行順は保証されない（アルファベット順だが将来変わる可能性あり）ため、順序に依らない作りにしましょう
￼。どうしても共有が必要な場合はフィクスチャで明示的に管理し、テスト間の隠れた依存を作らないことが肝要です。テストデータも使い回しせず、各テストが必要なデータセットを自前で用意する方が無難です
￼。例えば一つのテストでオブジェクトを生成・変更し、それを別のテストが参照する、といったことは厳禁です。
• カバレッジ（網羅率）との付き合い方:
コードカバレッジはテストがコードのどの程度を実行したか示す指標です。pytestではpytest-covプラグインで簡単に測定できます
￼。カバレッジは高いほど望ましいですが、闇雲に100%を目指す必要はありません。
￼一般的には重要なコードパスについて80%程度以上のカバレッジを目標にしつつ
￼、数字を上げること自体が目的とならないよう注意します
￼。100%を狙おうとすると意味の薄いテスト（例えば単純なgetter/setterまでテストする等）を書いてしまいがちですが、それよりも重要なロジックやエッジケースに注力したテストを書くほうが価値があります
￼。実際、カバレッジレポートを見るとテストされていない行がハイライトされるので、そこに重要な処理が残っていれば追加のテストを書く、といった使い方がおすすめです
￼。なお、自動生成されたボイラープレートコード（例:
データモデルの自動生成部分など）はカバレッジ集計から除外する設定も可能です
￼。カバレッジは指標であって目標ではないという点を常に念頭に置きましょう
￼。 • エッジケースとテスト対象の選定:
テストすべきケースとしては、いわゆる正常系だけでなく異常系・境界値をきちんと含めることが重要です
￼。例えば引数の範囲の端（0や最大値）、異常な入力（空文字やnull相当、型が違うもの）など、起こり得るあらゆるパターンを洗い出してテストケース化します
￼。一方で、テストを書くコストと見合わない部分は無理にテストしない判断も必要です。単純なゲッター・セッターや、UIの見た目のように自動テストしづらい部分は無理せず、重要なビジネスロジックや複雑な計算部分を重点的にテストしましょう。特にバグが混入しやすい箇所（複雑な条件分岐、外部入力を処理する箇所など）は漏れなくテストを書き、逆に変更可能性が低い単純処理は後回しでも構いません。TDDの文脈では「不安な所からテストを書く」とよく言われます。ご自身のコードでバグになりそうなポイントを洗い出し、そこを中心にテストケースを充実させてください。
• テストコードの品質:
テストコードもソフトウェアの一部なので可読性・保守性が重要です。冗長な重複はフィクスチャやヘルパー関数で解消し、意図が伝わるようリファクタリングしましょう
￼。例えば似たような初期化処理を複数のテストで繰り返しているならフィクスチャ化、魔法のような数値を直接比較しているなら変数名を付けて何を表すか明示、などです。またテストコードも定期的にレビュー・改善を行います
￼。動けばそれで良いと放置すると、いずれテスト自体が信頼できなくなります。命名が不適切なテストや不要になった古いテストは清掃し、常に「このテストは何を証明してくれるのか」を明確に保ちましょう。可読性の高いテストは将来の不具合解析の助けにもなります。
• 学習リソース: • 記事:
初心者向けにテストの心得をまとめた記事として、ONES社のブログ「Pythonの単体テストをマスターしよう：初心者でもわかる効率的な実践方法」などが参考になります。この中で命名規則やテスト独立性、テストコードのレビューについて触れられています
￼。また、Rost
Glukhov氏の個人ブログ「Pythonにおけるユニットテスト：例を交えた完全ガイド」は、基本から高度な話題・ベストプラクティスまで網羅した良記事です
￼
￼。日本語で丁寧に書かれており、一度目を通すと体系的な理解に役立つでしょう。
• 書籍:
テストコード設計やベストプラクティスを体系立てて学ぶには専門書も有用です。例えば
Vladimir Khorikov 著「単体テストの考え方/使い方 (Unit Testing
Principles, Practices, and Patterns)」
￼は、ユニットテストの原則やアンチパターンを解説した良書です（翻訳版が技術書として出版されています）。他にも「xUnit
Test Patterns」（英語）や和田卓人氏の「テスト駆動開発
(TDD)」など、テストに関する書籍・資料は多く紹介されています ￼
￼。時間に余裕があればこうした書籍で体系的に学ぶと、実践でブレない指針が身に付くでしょう。
• 発展トピック: 時間があれば、テスト駆動開発 (TDD)
や<strong>継続的インテグレーション
(CI)</strong>にも触れてみましょう。TDDはテストを書くことを軸に設計を進める手法で、ユニットテスト習熟後に挑戦すると開発観が広がります。またCI環境で自動的にテストを回す設定も習得すれば、チーム開発時にテストを回し忘れてバグを見逃す事故を防げます
￼。これらは本プランの範囲を超えますが、Week1〜5で学んだ内容が身についたら是非調べてみてください。</p>
<p>Week 6: 生成AIとテストの共存 –
AI支援開発における品質担保のベストプラクティス</p>
<p>テーマ:
ChatGPTなど生成AIを活用してコードを書く場合に、テストとどのように付き合うかを学びます。AI補助によるコーディングが普及する中でも、テストによる品質保証は不可欠です。ここではAI生成コードに対するテスト戦略や、AIをテスト作成に活用する方法などベストプラクティスを紹介します。
• AI生成コードも必ずテスト: 生成AI（例えばGitHub
CopilotやChatGPT）がコードを書いてくれるからといって、テストを省略してはいけません。AIが生成したコードであっても人間が書いたコードと同様、必ずユニットテストで検証する必要があります
￼。AIは文法的に正しいコードを返すことは得意ですが、そのロジックが正確か、境界条件まで正しく処理しているかは保証できません。むしろAIは与えられたプロンプトに対して一見それらしいコードを出すので、バグが紛れ込んでも見逃しがちです。だからこそテストスイートで網羅的にチェックし、人間の目では気付けない不具合も検出できるようにします
￼
￼。特に生成コードをプロジェクトに取り込む際は、レビューとテストを徹底し、十分なコードカバレッジを確保することが重要です
￼。AI支援でコーディングスピードが上がっても、テストを怠ればバグが混入するリスクも同時に増す点を忘れないでください。
• コードレビューとカバレッジ:
AIが書いたコードは、一見正しく見えても隠れた問題があるかもしれません。人間によるコードレビューに加え、自動テストで動作検証する二重のチェック体制が望ましいです
￼。特にセキュリティ面や境界条件など、AIが見落としそうな点にもテストケースを用意します。AIが新しいコードを生成したら、その部分のユニットテストを必ず追加・更新し、テストカバレッジを確認しましょう
￼。例えばCodacy社の提言では、AI生成コードがリリースに紛れ込んでしまわないよう「新規コードには常にテストを書き、カバレッジを担保する」ことが重要だとしています
￼。目安としては重要な箇所で80%以上のカバレッジを維持しつつ、過剰な100%目標は不要です（Week5参照）。カバレッジレポートで不足があれば追補し、逆に機械的に埋めるためだけのテストは避けましょう
￼。 • AIをテスト作成に活用:
生成AIはコードだけでなくテストコードの作成支援にも使えます。例えばChatGPTに「このクラスのユニットテストを書いて」とお願いすると、雛形となるテストコードを提案してくれます
￼。これは新人プログラマが先輩にレビューをもらうような感覚で、テストの抜け漏れを補完するのに役立ちます。ただし、生成AIの出力するテストはしばしば基本的なケースに留まることに注意してください。ChatGPTに任せっきりにせず、「他にテストすべきケースはある？」と問い直すことで追加のエッジケースを提案してもらうこともできます
￼。実際、CodecademyのチュートリアルではCalculatorクラスの基本テストをChatGPTに生成させた後、さらに「負の数」「ゼロ入力」「大きな数」「浮動小数点の丸め誤差」など考慮すべき追加ケースをChatGPTに尋ね、テストを強化しています
￼。このようにAIをペアプログラマ的に使い、思いつかないテストケースのヒントを得るのは有益です。
• プロンプト設計 (上級):
ChatGPT等にテストコードを書かせる際は、プロンプトに工夫が必要です。例えば「PEP8準拠で」「全ての分岐とエッジケースを網羅して」「fixtureやモックも適宜用いて」など具体的な要件を与えると、より質の高いテストコードを生成できます
￼。システムメッセージで「あなたはPythonテストのエキスパート」等のロールを与え、few-shotで理想的なテストの例を見せるといったテクニックも有効です
￼
￼。例えば「テスト関数名はtest_<機能名>_<条件>の形式にする」と指示すれば命名も改善されます
￼。生成結果はあくまで叩き台なので、得られたテストコードは必ず自分で実行して動作を確かめ、不十分な部分は修正しましょう。AIの提案に引っ張られすぎず、最終的な品質保証の責任は人間にあることを意識してください
￼。 • AI時代のテスト戦略:
AIによる自動化が進んでも、「テストを書かなくてよくなる」未来は当分来ません。むしろAIが生成したコードを人間がテストするという役割分担が一般的になるでしょう。日々の開発では、AI補助でコーディングを高速化しつつ、その成果物に常にテストを添えていく習慣を徹底してください
￼
￼。例えば、AIが出力したコードに対し「このコードのユニットテストも書いて」と続けて依頼し、自動生成されたテストをベースに手直しするのも良いやり方です
￼
￼。最終的には人間がテストを精査し、「網羅漏れはないか？」「無意味なテストになっていないか？」を判断します。AIは補助輪と割り切り、開発者自身のテスト設計力を向上させることで、将来にわたって保守・拡張しやすいコードベースを維持できるでしょう
￼。 • 参考資料: Codecademyの記事「How to use Generative AI for Unit
Testing」
￼は、ChatGPTを使ってPythonのユニットテストを作成・改善する具体的な手順を紹介しています。また、Codacyのブログ記事「Best
Practices for Coding with AI in
2024」には、AI支援コーディングで注意すべき点（コードのカプセル化や徹底したテストの重要性）がまとめられています
￼
￼。最新動向にキャッチアップする意味でも一読をおすすめします。AIとテストの関係はまだ新しい分野ですが、<strong>基本は「テストで品質を守る」</strong>というソフトウェア開発の原則が変わらないことを意識して学習を締めくくりましょう。</p>
<p>⸻</p>
<p>各週のプランに沿って進めれば、実践しながら体系的にテストコードの基礎力を養うことができます。週1.5～2時間という限られた学習時間でも、上記ステップを着実にこなすことで「テストを書けるPython開発者」へのステップアップが可能です。最後に、学んだ知識は必ず自身のプロジェクトで活用してみてください。実際のコードにテストを書き、AIで生成したコードにもテストを追加する経験を積むことで、学んだ内容が定着し、将来の保守・機能追加も安心して行えるようになるでしょう。頑張ってください！
￼ ￼</p>
<p>Sources:
ユニットテスト基礎とpytest使い方【9】【10】【32】、pytest高度機能【30】、テストベストプラクティス【25】【19】【20】、AIとテスト【6】【26】【7】等から引用・参考しました。</p>
</body>
</html>
