# このコードを読むための整理メモ

---

## まず最初に：この1行の全体像

```js
const plan = steps.filter(step => !skipSteps.has(step.step));
```

この1行は、

**「`steps` の中から、“スキップ対象ではないもの”だけを選び出して、新しい配列 `plan` として受け取っている」**

という意味のコードです。

まだ細かい仕組みは考えず、  
**“選別して、新しい結果を受け取っている”** と読めば十分です。

---

## 同じ処理を、理解しやすく書き換えた形

※ やっていることは完全に同じです  
※ 読みやすさのために分けています

```js
const plan = steps.filter(function (step) {
  const isSkipped = skipSteps.has(step.step);
  return !isSkipped;
});
```

さらに日本語寄りに読むと、

- `steps` を1つずつ `step` として取り出し
- その `step.step` が `skipSteps` に **含まれていないか** を調べ
- 含まれていないものだけを残す

という流れです。

---

## なぜこの整理が必要か（理由）

この1行が読みにくくなる理由は、

- **`step` が2回出てくる**（`step` と `step.step`）
- **否定（`!`）が条件の先頭にある**
- 「処理している最中なのか」「結果なのか」が一瞬わかりにくい

という点にあります。

コードとしては短いですが、  
**判断・否定・選別が一気に詰め込まれている**ため、初見では混乱しやすい形です。

---

## この1行で一番大事な考え方

### **filter は“条件に合うものだけを残す”**

この1行を読むとき、  
一番重要なのは **filter の役割**です。

---

## 用語による最小限の整理

- **`filter`**  
  - 正式には「配列のフィルタリング」  
  - 条件が `true` になる要素だけを集めた **新しい配列**を返す  
  - この1行では「スキップしない step だけを残す」役割

- **`has`**  
  - 指定した値が「含まれているか」を `true / false` で返す  
  - ここでは「この step はスキップ対象か？」を判断している

---

## スモールステップで意味を分解する

1. **何が用意されているか**  
   - `steps`：元になる配列  
   - `skipSteps`：除外したいものの集合  
   - `step`：配列から1つずつ取り出した要素

2. **何が実行（評価）されているか**  
   - `step.step` が `skipSteps` に含まれているかを調べる  
   - それを **否定**して、「含まれていないか？」を判定する

3. **何が結果として残るか**  
   - 「スキップ対象ではない step だけ」の配列  
   - それが `plan` に代入される

---

## 省略されていない形で見る（可能な場合のみ）

このコードは、

- 無名関数
- 条件式
- return の省略

がまとめて書かれています。

省略しない形にすると、先ほどの

```js
function (step) {
  return !skipSteps.has(step.step);
}
```

がその正体です。

---

## 最終まとめ（短文）

- この1行は、配列 `steps` から「スキップしないものだけ」を選んでいる  
- `filter` は「条件に合うものを残す」と読むのがコツ  
- `!` と `step.step` が重なっているため、一見わかりにくく感じやすい  

**短いけれど、“選別のロジック”が凝縮された1行**です。

